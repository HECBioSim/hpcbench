#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Standardise information from different benchmark outputs.
"""

from hpcbench.deps.numericalunits import s, ns, ms, hour, day, J
from hpcbench.plot.util import bodge_numeric_dict_wrapper
import copy
import json
import argparse
from hpcbench.logger import sacct

parser = argparse.ArgumentParser(
    description="Convert output from MD software (or othere simulations) to a"
                " standard format. Note: this is usually run automatically"
                " when simulation log files are parsed. You should only run"
                " this if something is missing from your output file.")
parser.add_argument("input", type=str, help="hpcbench json file")
parser.add_argument("output", type=str, help="Output json file")
parser.add_argument("-a", "--accounting", type=str, default="accounting.json",
                    help="hpcbench accounting file (usually generated by"
                    " hpcbench sacct or similar")
parser.add_argument("-t", "--totals", type=str, default="run",
                    help="location in input file of totals summary")

totals = {
        "Atoms": "2997924",
        "Elapsed(s)": "2366.06",
        "Per Step(ms)": "236.61",
        "ns/day": "0.73",
        "seconds/ns": "118302.93"
}

# TODO: add energy use: kwh/ns, kwh/step, kwh total, kwh/step/atom

unitlookup = {
    "Wall time (s)": s,
    "ns/day": ns/day,
    "ns/day,": ns/day,
    "day/ns": day/ns,
    "ns/s": ns/s,
    "s/ns": s/ns,
    "s/step": s,
    "hours/ns": hour/ns,
    "steps/s": 1/s,
    "step/s": 1/s,
    "Wall Clock Time (s)": s,
    "hours/ns,": hour/ns,
    "timesteps/s,": 1/s,
    "timesteps/s": 1/s,
    "Elapsed(s)": s,
    "seconds/ns": s/ns,
    "second/ns": s/ns,
    "Steps/second": 1/s,
    "Number of atoms": 1,
    "Atoms": 1,
    'CPU Time (s)': s,
    'Wall Clock Time including setup (s)': s,
    'Setup time': s,
    'Giga-Cycles': 1,
    'Mflops': 1,
    'Steps': 1,
    'Timestep': ns,
    'Timestep (ns)': ns,
    'Number of steps': 1,
    'hour/ns': hour/ns,
    "s/step": s,
    "Per Step(ms)": ms,
    "Consumed Energy (J)": J,
    'Simulation time (ns)': ns,
    'J/ns': J/ns,
    'ns/J': ns/J,
    'J/step': J,
    'step/J': 1/J,
}

# Used to rename quantities from the benchmark outputs so that they have the
# same names. Useful later when plotting results from different programs
# against one another.
crosswalk = {
    "Wall time (s)": "Wall Clock Time (s)",
    "timesteps/s,": "step/s",
    "Elapsed(s)": "Wall Clock Time (s)",
    "seconds/ns": "s/ns",
    "Steps/second": "step/s",
    "Steps/s": "step/s",
    "days/ns": "day/ns",
    'CPU Time (s)': "Wall Clock Time (s)",
    "Atoms": "Number of atoms",
    "timesteps/s": "step/s",
    "Per Step(ms)": "s/step",
    "ns/day,": "ns/day",
}

# The stanrdardised names of each quantity.
standard_original = {
    "Wall Clock Time (s)": None,
    "Number of atoms": None,
    "Number of steps": None,
    "Timestep (ns)": None,
    "Simulation time (ns)": None,
    "step/s": None,
    "ns/s": None,
    "ns/day": None,
    "s/step": None,
    "s/ns": None,
    "day/ns": None,
    "Consumed Energy (J)": None,
    "J/ns": None,
    "J/step": None,
}

def standardise_totals(totals, get_accounting="accounting.json"):
    """
    Rename quantities from a hpcbench output file to have standard names and
    units.
    
    Params:
        totals: the 'Totals' block from a hpcbench output file, a dictionary.
    
    Returns:
        The same block, with standardised names and units.
    """
    # On some systems, slurm will not reveal the consumed energy until the job
    # is finished - in these cases we get the energy again
    if get_accounting:
        with open(get_accounting, "r") as file:
            accounting = json.load(file)
        if "ConsumedEnergyRaw" in accounting:
            if accounting["ConsumedEnergyRaw"] == "0":
                accounting = sacct.get_sacct(accounting["JobID"])
                with open(get_accounting, "w") as file:
                    json.dump(accounting, file, indent=4)
            totals["Consumed Energy (J)"] = accounting["ConsumedEnergyRaw"]
    
    standard = copy.copy(standard_original)
    totals = bodge_numeric_dict_wrapper(totals)

    # Identify names and units of quantities
    for name, value in totals.items():
        units = unitlookup[name]
        if name in crosswalk:
            name = crosswalk[name]
        if name in standard:
            standard[name] = value * units

    # If ns/s is missing, convert ns/day to units of ns/s
    if standard["ns/s"] is None and standard["ns/day"] is not None:
        unitless = standard["ns/day"] / (ns/day)
        converted = unitless / (day/s)
        standard["ns/s"] = converted * ns/s
    
    if standard["step/s"] is None and standard["Wall Clock Time (s)"]:
        if 'Steps' in totals:
            standard["step/s"] = totals['Steps'] / \
                standard["Wall Clock Time (s)"]
                
    # If 'consumed energy' is populated, add energy/ns and energy/step
    if standard["J/ns"] is None and standard["Simulation time (ns)"] \
        is not None and standard["Consumed Energy (J)"]:
        standard["J/ns"] = standard["Consumed Energy (J)"] / \
            standard["Simulation time (ns)"]
    if standard["J/step"] is None and standard["Number of steps"] \
        is not None and standard["Consumed Energy (J)"]:
        standard["J/step"] = standard["Consumed Energy (J)"] / \
            standard["Number of steps"]


    # Set missing values of reciprocals
    for name, value in standard.items():
        if value is None:
            if "/" in name:
                backwards = "/".join(list(reversed(name.split("/"))))
                if backwards in standard and standard[backwards] is not None:
                    standard[name] = 1/standard[backwards]
    
    # Give quantities back in real units
    for key, value in standard.items():
            try:
                standard[key] = (value / unitlookup[key])
            except TypeError:
                print("No "+str(key))
                import sys
                sys.exit()
    
    return standard

if __name__ == "__main__":
    args = parser.parse_args()
    with open(args.input, "r") as file:
        benchout = json.load(file)
    totals = benchout[args.totals]
    totals = standardise_totals(totals, get_accounting=args.accounting)
    benchout[args.totals] = totals
    with open(args.output, "w") as outfile:
        json.dump(benchout, outfile, indent=4)
