#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Standardise information from different benchmark outputs.
"""

from hpcbench.deps.numericalunits import s, ns, ms, hour, day, J
from hpcbench.plot.util import bodge_numeric_dict_wrapper
import copy
import json
import argparse
from hpcbench.logger import sacct

parser = argparse.ArgumentParser(
    description="Convert output from MD software (or othere simulations) to a"
                " standard format. Note: this is usually run automatically"
                " when simulation log files are parsed. You should only run"
                " this if something is missing from your output file.")
parser.add_argument("input", type=str, help="hpcbench json file")
parser.add_argument("output", type=str, help="Output json file")
parser.add_argument("-a", "--accounting", type=str, default="accounting.json",
                    help="hpcbench accounting file (usually generated by"
                    " hpcbench sacct or similar")
parser.add_argument("-t", "--totals", type=str, default="run",
                    help="location in input file of totals summary. Can use a "
                    ": to represent nesting, e.g. loc1:loc2.")


totals = {
        "Atoms": "2997924",
        "Elapsed(s)": "2366.06",
        "Per Step(ms)": "236.61",
        "ns/day": "0.73",
        "seconds/ns": "118302.93"
}

# these are useful, i might put them in a util.py
def dget(dct, keys):
    for key in keys:
        dct = dct[key]
    return dct

def dset(dct, keys, value):
    for key in keys[:-1]:
        dct = dct.setdefault(key, {})
    dct[keys[-1]] = value

# TODO: add energy use: kwh/ns, kwh/step, kwh total, kwh/step/atom

unitlookup = {
    "Wall time (s)": s,
    "ns/day": ns/day,
    "ns/day,": ns/day,
    "day/ns": day/ns,
    "ns/s": ns/s,
    "s/ns": s/ns,
    "s/step": s,
    "hours/ns": hour/ns,
    "steps/s": 1/s,
    "step/s": 1/s,
    "Wall Clock Time (s)": s,
    "hours/ns,": hour/ns,
    "timesteps/s,": 1/s,
    "timesteps/s": 1/s,
    "Elapsed(s)": s,
    "seconds/ns": s/ns,
    "second/ns": s/ns,
    "Steps/second": 1/s,
    "Number of atoms": 1,
    "Atoms": 1,
    'CPU Time (s)': s,
    'Wall Clock Time including setup (s)': s,
    'Setup time': s,
    'Giga-Cycles': 1,
    'Mflops': 1,
    'Steps': 1,
    'Timestep': ns,
    'Timestep (ns)': ns,
    'Number of steps': 1,
    'hour/ns': hour/ns,
    "s/step": s,
    "Per Step(ms)": ms,
    "Consumed Energy (J)": J,
    'Simulation time (ns)': ns,
    'J/ns': J/ns,
    'ns/J': ns/J,
    'J/step': J,
    'step/J': 1/J,
}

# Used to rename quantities from the benchmark outputs so that they have the
# same names. Useful later when plotting results from different programs
# against one another.
crosswalk = {
    "Wall time (s)": "Wall Clock Time (s)",
    "timesteps/s,": "step/s",
    "Elapsed(s)": "Wall Clock Time (s)",
    "seconds/ns": "s/ns",
    "Steps/second": "step/s",
    "Steps/s": "step/s",
    "days/ns": "day/ns",
    'CPU Time (s)': "Wall Clock Time (s)",
    "Atoms": "Number of atoms",
    "timesteps/s": "step/s",
    "Per Step(ms)": "s/step",
    "ns/day,": "ns/day",
    "Steps": "Number of steps",
}

# The stanrdardised names of each quantity.
standard_original = {
    "Wall Clock Time (s)": None,
    "Number of atoms": None,
    "Number of steps": None,
    "Timestep (ns)": None,
    "Simulation time (ns)": None,
    "step/s": None,
    "ns/s": None,
    "ns/day": None,
    "s/step": None,
    "s/ns": None,
    "day/ns": None,
    "Consumed Energy (J)": None,
    "J/ns": None,
    "J/step": None,
}

def standardise_totals(totals, get_accounting="accounting.json"):
    """
    Rename quantities from a hpcbench output file to have standard names and
    units.
    
    Params:
        totals: the 'Totals' block from a hpcbench output file, a dictionary.
        accounting: a string, either the location of the 'accounting' file
        produced by hpcbench sacct, or the job id, to get a new accounting file
    Returns:
        The same block, with standardised names and units.
    """
    standard = copy.copy(standard_original)
    totals = bodge_numeric_dict_wrapper(totals)

    # On some systems, slurm will not reveal the consumed energy until the job
    # is finished - in these cases we get the energy again
    if get_accounting:
        try:
            with open(get_accounting, "r") as file:
                accounting = json.load(file)
            if "ConsumedEnergyRaw" in accounting:
                if accounting["ConsumedEnergyRaw"] == "0" \
                or accounting["ConsumedEnergyRaw"] == 0:
                    accounting = sacct.get_sacct(accounting["JobID"])
                    with open(get_accounting, "w") as file:
                        json.dump(accounting, file, indent=4)
                totals["Consumed Energy (J)"] = float(
                    accounting["ConsumedEnergyRaw"])
        except FileNotFoundError:
            accounting = sacct.get_sacct(get_accounting)
            totals["Consumed Energy (J)"] = float(
                accounting["ConsumedEnergyRaw"])

    # Identify names and units of quantities
    for name, value in totals.items():
        units = unitlookup[name]
        if name in crosswalk:
            name = crosswalk[name]
        if name in standard:
            standard[name] = value * units

    # If ns/s is missing, convert ns/day to units of ns/s
    if standard["ns/s"] is None and standard["ns/day"] is not None:
        unitless = standard["ns/day"] / (ns/day)
        converted = unitless / (day/s)
        standard["ns/s"] = converted * ns/s
    
    if standard["step/s"] is None and standard["Wall Clock Time (s)"]:
        if 'Steps' in totals:
            standard["step/s"] = totals['Steps'] / \
                standard["Wall Clock Time (s)"]
    
    # If 'consumed energy' is populated, add energy/ns and energy/step
    isset = lambda n : n != 0 and n != None
    if not isset(standard["J/ns"]) and standard["Simulation time (ns)"] \
        is not None and get_accounting:
        standard["J/ns"] = standard["Consumed Energy (J)"] / \
            standard["Simulation time (ns)"]
    if not isset(standard["J/step"]) and standard["Number of steps"] \
        is not None and get_accounting:
        standard["J/step"] = standard["Consumed Energy (J)"] / \
            standard["Number of steps"]


    # Set missing values of reciprocals
    for name, value in standard.items():
        if value is None:
            if "/" in name:
                backwards = "/".join(list(reversed(name.split("/"))))
                if backwards in standard and standard[backwards] is not None:
                    standard[name] = 1/standard[backwards]
    
    # Give quantities back in real units
    for key, value in standard.items():
            try:
                standard[key] = (value / unitlookup[key])
            except TypeError as e:
                print("No unit for "+str(key))
                raise e
    
    return standard

if __name__ == "__main__":
    args = parser.parse_args()
    with open(args.input, "r") as file:
        benchout = json.load(file)
    if ":" in args.totals:
        locs = args.totals.split(":")
        totals = dget(benchout, locs)
        totals = standardise_totals(totals, get_accounting=args.accounting)
        dset(benchout, locs, totals)
    elif args.totals in benchout:
        totals = benchout[args.totals]
        totals = standardise_totals(totals, get_accounting=args.accounting)
        benchout[args.totals] = totals
    else:
        benchout = standardise_totals(benchout, get_accounting=args.accounting)
    with open(args.output, "w") as outfile:
        json.dump(benchout, outfile, indent=4)
