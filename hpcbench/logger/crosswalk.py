#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Standardise information from different benchmark outputs.
"""

from hpcbench.deps.numericalunits import s, ns, ms, hour, day, J
from hpcbench.plot.util import bodge_numeric_dict_wrapper
import copy
import json
import argparse
from hpcbench.logger import sacct
import os
import glob

parser = argparse.ArgumentParser(
    description="Convert output from MD software (or othere simulations) to a"
                " standard format. Note: this is usually run automatically"
                " when simulation log files are parsed. You should only run"
                " this if something is missing from your output file.")
parser.add_argument("input", type=str, help="hpcbench json file")
parser.add_argument("-o", "--output", type=str, help="Output json file. If "
                    "none is provided, the input file will be overwritten")
parser.add_argument("-a", "--accounting", type=str, default="accounting.json",
                    help="hpcbench accounting file (usually generated by"
                    " hpcbench sacct or similar")
parser.add_argument("-t", "--totals", type=str, default="run",
                    help="location in input file of totals summary. Can use a "
                    ": to represent nesting, e.g. loc1:loc2.")


# these are useful, i might put them in a util.py


def dget(dct, keys):
    for key in keys:
        dct = dct[key]
    return dct


def dset(dct, keys, value):
    for key in keys[:-1]:
        dct = dct.setdefault(key, {})
    dct[keys[-1]] = value


unitlookup = {
    "Wall time (s)": s,
    "ns/day": ns/day,
    "ns/day,": ns/day,
    "day/ns": day/ns,
    "ns/s": ns/s,
    "s/ns": s/ns,
    "s/step": s,
    "hours/ns": hour/ns,
    "steps/s": 1/s,
    "step/s": 1/s,
    "Wall Clock Time (s)": s,
    "hours/ns,": hour/ns,
    "timesteps/s,": 1/s,
    "timesteps/s": 1/s,
    "Elapsed(s)": s,
    "seconds/ns": s/ns,
    "second/ns": s/ns,
    "Steps/second": 1/s,
    "Number of atoms": 1,
    "Atoms": 1,
    'CPU Time (s)': s,
    'Wall Clock Time including setup (s)': s,
    'Setup time': s,
    'Giga-Cycles': 1,
    'Mflops': 1,
    'Steps': 1,
    'Timestep': ns,
    'Timestep (ns)': ns,
    'Number of steps': 1,
    'hour/ns': hour/ns,
    "s/step": s,
    "Per Step(ms)": ms,
    "Consumed Energy (J)": J,
    'Simulation time (ns)': ns,
    'J/ns': J/ns,
    'ns/J': ns/J,
    'J/step': J,
    'step/J': 1/J,
}

# Used to rename quantities from the benchmark outputs so that they have the
# same names. Useful later when plotting results from different programs
# against one another.
crosswalk = {
    "Wall time (s)": "Wall Clock Time (s)",
    "timesteps/s,": "step/s",
    "Elapsed(s)": "Wall Clock Time (s)",
    "seconds/ns": "s/ns",
    "Steps/second": "step/s",
    "Steps/s": "step/s",
    "days/ns": "day/ns",
    'CPU Time (s)': "Wall Clock Time (s)",
    "Atoms": "Number of atoms",
    "timesteps/s": "step/s",
    "Per Step(ms)": "s/step",
    "ns/day,": "ns/day",
    "Steps": "Number of steps",
    "Total Energy (J)": "Consumed Energy (J)",
}

# The stanrdardised names of each quantity.
standard_original = {
    "Wall Clock Time (s)": None,
    "Number of atoms": None,
    "Number of steps": None,
    "Timestep (ns)": None,
    "Simulation time (ns)": None,
    "step/s": None,
    "ns/s": None,
    "ns/day": None,
    "s/step": None,
    "s/ns": None,
    "day/ns": None,
    "Consumed Energy (J)": None,
    "J/ns": None,
    "J/step": None,
}


def standardise_totals(totals, get_accounting="accounting.json", infile=None):
    """
    Rename quantities from a hpcbench output file to have standard names and
    units.

    Params:
        totals: the 'Totals' block from a hpcbench output file, a dictionary.
        accounting: a string, either the location of the 'accounting' file
        produced by hpcbench sacct, or the job id, to get a new accounting file
        infile: location of the input file. Useful to try and obtain
        accounting info if it can't be found in accounting.json.'
    Returns:
        The same block, with standardised names and units.
    """
    standard = copy.copy(standard_original)
    totals = bodge_numeric_dict_wrapper(totals)

    # Get accounting info - this is messy because it needs a lot of fallbacks
    # for different scenarios, e.g. when the accounting data in the json file
    # doesn't exist or is incomplete
    if get_accounting:
        try:
            with open(get_accounting, "r") as file:  # accounting file is given
                accounting = json.load(file)
            if "ConsumedEnergyRaw" in accounting:
                if accounting["ConsumedEnergyRaw"] == "0" or accounting[
                        "ConsumedEnergyRaw"] == 0:
                    accounting = sacct.get_sacct(accounting["JobID"])
                    with open(get_accounting, "w") as file:
                        json.dump(accounting, file, indent=4)
                totals["Consumed Energy (J)"] = float(
                    accounting["ConsumedEnergyRaw"])
            if "Totals" in accounting:
                powertotals = accounting["Totals"]
                if "Total Energy (J)" in powertotals:
                    totals["Consumed Energy (J)"] = float(
                        powertotals["Total Energy (J)"])
                if "Consumed Energy (J)" in powertotals:
                    totals["Consumed Energy (J)"] = float(
                        powertotals["Total Energy (J)"])
        except FileNotFoundError:
            if "." not in get_accounting:  # job id is provided directly
                accounting = sacct.get_sacct(get_accounting)
                totals["Consumed Energy (J)"] = float(
                    accounting["ConsumedEnergyRaw"])
            else:
                folder = os.path.dirname(infile)
                matching = glob.glob(folder+os.path.sep+"slurm-"+"*")
                if len(matching) == 0:
                    folder = os.getcwd()
                    matching = glob.glob(folder+os.path.sep+"slurm-"+"*")
                slurmids = []
                for file in matching:
                    slurmids.append(file.split("-")[-1].split(".")[0])
                slurmid = max(slurmids)
                accounting = sacct.get_sacct(slurmid)
                totals["Consumed Energy (J)"] = float(
                    accounting["ConsumedEnergyRaw"])

    # Identify names and units of quantities
    for name, value in totals.items():
        units = unitlookup[name]
        if name in crosswalk:
            name = crosswalk[name]
        if name in standard:
            standard[name] = value * units

    # If ns/s is missing, convert ns/day to units of ns/s
    if standard["ns/s"] is None and standard["ns/day"] is not None:
        unitless = standard["ns/day"] / (ns/day)
        converted = unitless / (day/s)
        standard["ns/s"] = converted * ns/s

    if standard["step/s"] is None and standard["Wall Clock Time (s)"]:
        if 'Steps' in totals:
            standard["step/s"] = totals['Steps'] / \
                standard["Wall Clock Time (s)"]

    # If 'consumed energy' is populated, add energy/ns and energy/step
    def isset(n): return n != 0 and n is not None
    if not isset(standard["J/ns"]) and standard[
            "Simulation time (ns)"] is not None and get_accounting:
        standard["J/ns"] = standard["Consumed Energy (J)"] / \
            standard["Simulation time (ns)"]
    if not isset(standard["J/step"]) and standard[
            "Number of steps"] is not None and get_accounting:
        standard["J/step"] = standard["Consumed Energy (J)"] / \
            standard["Number of steps"]

    # Set missing values of reciprocals
    for name, value in standard.items():
        if value is None:
            if "/" in name:
                backwards = "/".join(list(reversed(name.split("/"))))
                if backwards in standard and standard[backwards] is not None:
                    standard[name] = 1/standard[backwards]

    # Give quantities back in real units
    for key, value in standard.items():
        try:
            standard[key] = (value / unitlookup[key])
        except TypeError as e:
            print("No unit for "+str(key))
            raise e

    for key, value in standard.items():
        standard[key] = str(standard[key])

    return standard


if __name__ == "__main__":
    args = parser.parse_args()
    with open(args.input, "r") as file:
        benchout = json.load(file)
    if ":" in args.totals:
        locs = args.totals.split(":")
        totals = dget(benchout, locs)
        totals = standardise_totals(totals, get_accounting=args.accounting,
                                    infile=args.input)
        dset(benchout, locs, totals)
    elif args.totals in benchout:
        totals = benchout[args.totals]
        totals = standardise_totals(totals, get_accounting=args.accounting,
                                    infile=args.input)
        benchout[args.totals] = totals
    else:
        benchout = standardise_totals(benchout, get_accounting=args.accounting,
                                      infile=args.input)
    if not args.output:
        args.output = args.input
    with open(args.output, "w") as outfile:
        json.dump(benchout, outfile, indent=4)
